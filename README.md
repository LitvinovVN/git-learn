# Инструкция по работе с Git
## Основы Git
Git — это распределенная система контроля версий нашего кода. Проще говоря она нужна чтобы отслеживать изменения, которые происходят со временем.
## Установка Git
### Установка для Windows
Качаем дистриб по ссылке https://git-scm.com/download/win
### Установка для macOS
Качаем дистриб по ссылке https://git-scm.com/download/mac
### Установка для Linux
Качаем дистриб по ссылке https://git-scm.com/download/linux
## Настройка Git
У гита должен быть пользователь, от лица которого будет вестись работа. Это обязательно, т.к. когда создается коммит, гит берет именно эту информацию для поля Author. Чтобы настроить имя пользователя и пароль для всех проектов, нужно прописать ледующие команды:

*git config --global user.name ”**Roman Korostin**”*

*git config --global user.email **rkorostin@gmail.com***

Если есть необходимость для конкретного проекта поменять автора (для личного проекта, например), можно убрать --global, и так получится:

*git config user.name ”**Ivan Ivanov**”*

*git config user.email **iivanov@gmail.com***
## Что нужно помнить?

### Гит репозиторий
Гит репозиторий — это все файлы, находящиеся под контролем версий, вместе с историей их изменения.
### Коммит
Коммит — это основной объект в управлении контроля версий. Он содержит все изменения за время этого коммита. Коммиты связаны между с собой как односвязный список. Т.е., например, есть первый коммит. Когда создается второй коммит, то он (второй) знает, что идет после первого.
Коммит включает в себя информацию:
* Уникальный идентификатор коммита, по которому можно его найти;
* Имя автора коммита, который создал его;
* Дата создания коммита;
* Комментарий, который описывает, что было сделано во время этого коммита.
## Начало работы с локальным Git
1. Чтобы создать локальный репозиторий, нужно написать:*git init*. Результатом команды будет создание скрытой папки ***.git***
2. Далее, добавляются файлы в этот проект. Чтобы посмотреть, какой статус работы на данный момент, пишем: *git status*. Будет видно, какие файлы изменены, но еще не добавлены в состояние staged.
3. Чтобы добавить файлы в состояние staged, нужно написать *git add*.
Здесь может быть несколько вариантов, например:
* *git add .* — добавить все файлы из этой папки и все внутренних.
* *git add <имя файла>* — добавляет только конкретный файл. 
4. Последний этап — закоммитить и создать новый коммит: *git commit -m “комментарии к коммиту”*
5. Чтобы посмотреть на все коммиты: *git log*
![git log](/git_log.PNG)
6. Посмотреть на изменения, которые были произведены над файлом: *git diff*
7. Переход от одного коммита к другому: *git checkout <первые 4 символа коммита>*
## Ветвление
Ветвление - это копия оригинального проекта (ветка, branch)
### Создание новой ветки
*git branch <имя ветки>*

Это создаст новую ветку, но это будет точная копия ветки master
### Переключение между ветками
*git branch*

Отобразятся все созданные ветки проекта. Выделенная звездочкой ветка - будет текущей веткой. Самая главная ветка - *master*

Для переключения на нужную ветку необходимо выполнить:
*git checkout <имя ветки>*

*Важно помнить, что пока не закомитили изменения, переключиться на другую ветку нельзя*
### Слияние веток
Мы создали новую ветку, например, *new_feature*.Создали в ней новый файл, например, **feature.txt**! Закоммитили. Теперь можно переключиться на ветку *master* обратно. Переключились на ветку *master*. Но там нет нового созданного файла **feature.txt**! Чтобы он появился, нужно воспользоваться *merge* для объединения веток:

*git merge new_feature*

После слияния ветка *new_feature* больше не актуальна и её можно удалить:

*git branch -d new_feature*

### Разрешение конфликтов при слиянии
Допустим есть проект, над которым работает команда разработчиков. В этом проекте есть ветка **branch_Roman**, в которой работает Роман, и есть ветка **branch_Ivan**, в которой работает Иван. В этих ветках Роман и Иван правят одну и ту же функцию и оба коммитят код в свою ветку. Теперь, если или Роман или Иван попытаются слить свою ветку в проект, то они получат сообщение об ошибке **Система не смогла разрешить конфликт автоматически. Это придется сделать разработчикам**. Помимо данного сообщения будут отмечены строки, содержашие конфликт.

## Пример слияния с конфликтом
Строка **74** принадлежит ветке *master*.Для этой строки создаем конфликт.
Строка **74** принадлежит ветке *master*. Но в ветке copy4 есть такая же строка. Как быть, что оставим?
Оставим оба варианта - accept both changes

## Работа с удаленными репозиториями
### Подготовка работы с удалёнными репозиториями
1. Зарегистрироваться на любом сервисе гит, например, на github.com
2. В новом аккаунте создать репозиторий
3. Создать ssh-key для работы с удалённым репозиторием:

*ssh-keygen.exe -t ed25519 -b 4096*

Ввести _имя ключа_, например, *ssh-key-01*

Ввести пароль (придумать свой, любой)

4. Если отсутствует директория *~/.ssh* на локальном ПК - создать:
*mkdir ~/.ssh*
5. Скопировать созданные в п.3 ключи в директорию *~/.ssh*
### Работа с удаленными директориями
1. Запустить ssh-агент:

*eval "$(ssh-agent -s)"*

2. Добавить ключ (из директории *~/.ssh*):

*ssh-add ~/.ssh/ssh-key-01*

Ввести пароль

3. Клонировать удалённый репозиторий на свой ПК:

*git clone \<SSH code>*

4. Перейти в скопированный репозиторий:

*cd \<путь к репозиторию>*

5. Создать копию проекта в новой ветке и вести работу только в новой ветке
6. После коммита можно отправлять изменения в удаленный репозиторий:

*git push*
## Работа с чужими репозиториями
1. Форкнуть чужой репозиторий (Проще говоря - сделать копию чужого репозитория в своём аккаунте). 
2. Повторить с 1-го по 6-ой пункты из раздела **Работа с удаленными директориями**
3. Сделать *pull requests* скопированного репозитория